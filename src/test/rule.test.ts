import { datastore as ds, UserService, Rule, RuleKey, RuleService as rs } from '../models';
import { assert } from 'chai';

describe("Rule", function() {
  let ownerId: string;
  let nonNumericOwnerId: string;

  beforeEach(async function() {
    let user = UserService.makeNew();
    let [id] = await UserService.save([user]);
    if (! id) {
      throw new Error('Created new user but did not get back id');
    }
    ownerId = id;

    // Create another user with non-numeric ownerId
    nonNumericOwnerId = user.id = 'xxx:' + id;
    await UserService.save([user]);
  });

  function newRule(): Rule {
    let ret = rs.makeNew(ownerId);
    ret.type = 'GLOB';
    ret.pattern = '1.23';
    ret.rank = 0;
    ret.dest = '/pics';
    return ret;
  }

  it('validation: valid rule', function() {
    let rule: Rule = {
      type: 'NAME_CONTAINS',
      pattern: '123',
      rank: 0,
      dest: '/there',
      created: new Date()
    };
    let error = rs.validate([rule]);
    assert.notOk(error);
  });

  it('validation: invalid type', function() {
    let rule: Rule = {
      type: 'moose',
      pattern: '123',
      rank: 0,
      dest: '/there',
      created: new Date()
    };
    let error = rs.validate([rule]);
    assert.ok(error);
  });

  it('validation: pattern cannot contain /', function() {
    let rule: Rule = {
      type: 'NAME_CONTAINS',
      pattern: '12/3',
      rank: 0,
      dest: '/there',
      created: new Date()
    };
    let error = rs.validate([rule]);
    assert.ok(error);
  });

  it('validation: type is ext_eq and pattern cannot contain .', function() {
    let rule: Rule = {
      type: 'EXT_EQ',
      pattern: '12.3',
      rank: 0,
      dest: '/there',
      created: new Date()
    };
    let error = rs.validate([rule]);
    assert.ok(error);
  });

  it('validation: pattern can contain if type is not EXT_EQ', function() {
    let rule: Rule = {
      type: 'GLOB',
      pattern: '12.3',
      rank: 0,
      dest: '/there',
      created: new Date()
    };
    let error = rs.validate([rule]);
    assert.notOk(error);
  });

  it('validation: dest must start with /', function() {
    let rule: Rule = {
      type: 'GLOB',
      pattern: '12.3',
      rank: 0,
      dest: 't/here',
      created: new Date()
    };
    let error = rs.validate([rule]);
    assert.ok(error);
  });

  it('validation: dest must start with /', function() {
    let rule: Rule = {
      type: 'GLOB',
      pattern: '12.3',
      rank: 0,
      dest: 't/here',
      created: new Date()
    };
    let error = rs.validate([rule]);
    assert.ok(error);
  });


  it('save(): invalid dest throws error', async function() {
    let rule = newRule();
    rule.dest  = '';
    let thrown = true;
    try {
      await rs.save([rule]);
      thrown = false;
    } catch (e) {}
    assert.ok(thrown);
  });

  it('save(): missing id throws error', async function() {
    let rule = newRule();
    rule.id = undefined;
    let thrown = true;
    try {
      await rs.save([rule]);
      thrown = false;
    } catch (e) {}
    assert.ok(thrown);
  });

  it('save(): missing id.ownerId throws error', async function() {
    let rule = newRule();
    assert.ok(rule.id);
    rule.id && (rule.id.ownerId = undefined);
    let thrown = true;
    try {
      await rs.save([rule]);
      thrown = false;
    } catch (e) {}
    assert.ok(thrown);
  });

  it('save(): can save with missing ruleId', async function() {
    let rule = newRule();
    let [id] = await rs.save([rule]);
    assert.ok(id);
    if (id) {
      assert.equal(id.ownerId, ownerId);
      assert.ok(id.ruleId);
    }
  });

  it('save(): can save with missing ruleId and get it back', async function() {
    let rule = newRule();
    let id: RuleKey;
    [id] = await rs.save([rule]) as RuleKey[];
    assert.ok(id);
    assert.equal(id.ownerId, ownerId);
    assert.ok(id.ruleId);
    let [fromDS] = await rs.findByIds([id]);
    // ruleId is generated by datastore, let's add it to the rule that we
    // created
    rule.id = id;
    assert.deepEqual(fromDS, rule);
  });

  it('save(): modify rule with id save, then read it back', async function() {
    let rule = newRule();
    let id: RuleKey;
    [id] = await rs.save([rule]) as RuleKey[];
    assert.ok(id);
    assert.equal(id.ownerId, ownerId);
    assert.ok(id.ruleId);
    let [fromDS] = await rs.findByIds([id]);
    // ruleId is generated by datastore, let's add it to the rule that we
    // created
    rule.id = id;
    assert.deepEqual(fromDS, rule);

    // Mod
    rule.dest = '/newdest';
    await rs.save([rule]);
    [fromDS] = await rs.findByIds([id]);
    assert.deepEqual(fromDS, rule);
  });

  it('save(): modify rule with id save, then read it back, non-numeric parent', async function() {
    let rule = newRule();
    (rule.id as RuleKey).ownerId = nonNumericOwnerId;
    let id: RuleKey;
    [id] = await rs.save([rule]) as RuleKey[];
    assert.ok(id);
    assert.equal(id.ownerId, nonNumericOwnerId);
    assert.ok(id.ruleId);
    let [fromDS] = await rs.findByIds([id]);
    // ruleId is generated by datastore, let's add it to the rule that we
    // created
    rule.id = id;
    assert.deepEqual(fromDS, rule);

    // Mod
    rule.dest = '/newdest';
    await rs.save([rule]);
    [fromDS] = await rs.findByIds([id]);
    assert.deepEqual(fromDS, rule);
  });

  it('toEntity(): cannot convert rule with missing id', async function() {
    let rule = newRule();
    rule.id = undefined;
    let thrown = true;
    try {
      rs.toEntity(rule);
      thrown = false;
    } catch (e) { }
    assert.isTrue(thrown);
  });

  it('toEntity(): cannot convert rule with missing ownerId', async function() {
    let rule = newRule();
    let rk = new RuleKey();
    rk.ruleId = '123';
    rule.id = rk;
    let thrown = true;
    try {
      rs.toEntity(rule);
      thrown = false;
    } catch (e) { }
    assert.isTrue(thrown);
  });

  it('toEntity(): can convert rule with missing ruleId', async function() {
    let rule = newRule();
    let rk = new RuleKey();
    rk.ownerId = 'sup';
    rk.ruleId = undefined;
    rule.id = rk;
    rs.toEntity(rule);
  });

  it('keyFromId(): cannot convert missing id', async function() {
    let thrown = true;
    try {
      rs.keyFromId(undefined);
      thrown = false;
    } catch (e) { }
    assert.isTrue(thrown);
  });

  it('keyFromId(): cannot convert missing ownerId', async function() {
    let rk = new RuleKey();
    rk.ownerId = undefined;
    rk.ruleId = '123';
    let thrown = true;
    try {
      rs.keyFromId(rk);
      thrown = false;
    } catch (e) { }
    assert.isTrue(thrown);
  });

  it('keyFromId(): converts non-numeric ownerId to name', async function() {
    let rk = new RuleKey();
    rk.ownerId = 'xyz123';
    rk.ruleId = undefined;
    let k = rs.keyFromId(rk);
    assert.ok(k);
    // should be an incomplete key
    assert.equal(k.kind, rs.kind);
    assert.notOk(k.id);
    assert.ok(k.parent);

    // parent should be user
    assert.equal((k.parent as any).kind, UserService.kind);
    assert.equal((k.parent as any).name, rk.ownerId);
  });

  it('keyFromId(): converts numeric ownerId to name', async function() {
    let rk = new RuleKey();
    rk.ownerId = '123';
    rk.ruleId = undefined;
    let k = rs.keyFromId(rk);
    assert.ok(k);
    // should be an incomplete key
    assert.equal(k.kind, rs.kind);
    assert.notOk(k.id);
    assert.ok(k.parent);

    // parent should be user
    assert.equal((k.parent as any).kind, UserService.kind);
    assert.equal((k.parent as any).id, rk.ownerId);
  });

  it('keyFromId(): converts ruleId', async function() {
    let rk = new RuleKey();
    rk.ownerId = '123';
    rk.ruleId = '555';
    let k = rs.keyFromId(rk);
    assert.ok(k);

    // should be an incomplete key
    assert.equal(k.kind, rs.kind);
    assert.equal(k.id, rk.ruleId);
    assert.ok(k.parent);

    // parent should be user
    assert.equal((k.parent as any).kind, UserService.kind);
    assert.equal((k.parent as any).id, rk.ownerId);
  });


  it('idFromKey(): cannot handle empty key', function() {
    assert.throw(function() {
      rs.idFromKey(undefined as any);
    });
  });

  it('idFromKey(): numeric parent key', function() {
    let rk = new RuleKey();
    rk.ownerId = '123';
    rk.ruleId = '555';
    let k = ds.key([UserService.kind, ds.int(rk.ownerId), rs.kind, ds.int(rk.ruleId)]);
    let actual = rs.idFromKey(k);
    assert.deepEqual(actual, rk);
  });

  it('idFromKey(): non-numeric parent key', function() {
    let rk = new RuleKey();
    rk.ownerId = '123x';
    rk.ruleId = '555';
    let k = ds.key([UserService.kind, rk.ownerId, rs.kind, ds.int(rk.ruleId)]);
    let actual = rs.idFromKey(k);
    assert.deepEqual(actual, rk);
  });

  it('idFromKey() then keyFromId() returns the same as original input', function() {
    let rk = new RuleKey();
    rk.ownerId = '123';
    rk.ruleId = '555';
    let k = rs.keyFromId(rk);
    let actual = rs.idFromKey(k);
    assert.deepEqual(actual, rk);
  });

  it('idFromKey() then keyFromId() returns the same as original input, non-numeric parent', function() {
    let rk = new RuleKey();
    rk.ownerId = 'x123';
    rk.ruleId = '555';
    let k = rs.keyFromId(rk);
    let actual = rs.idFromKey(k);
    assert.deepEqual(actual, rk);
  });

  it("findByOwner()", async function() {
    let user = UserService.makeNew();
    [user.id] = await UserService.save([user]);
    let rules: Rule[] = [];
    for (let i = 0; i < 5; i++) {
      let rule = newRule();
      rule.rank = i;
      if (rule.id) {
        rule.id.ownerId = user.id;
      }
      rules.push(rule);
    }
    let ruleIds = await rs.save(rules);
    ruleIds.forEach((id, index) => {
      rules[index].id = id;
    });

    let fromDS = await rs.findByOwner(user.id as string);
    assert.deepEqual(fromDS, rules);
  });

  it("matches() EXT_EQ works basic case", async function() {
    let rule: Rule = {
      type: 'EXT_EQ',
      pattern: 'f',
    };
    function test() {
      assert.isTrue(rs.matches(rule, 'testing.f'));
      assert.isTrue(rs.matches(rule, 'testing.F'));
      assert.isTrue(rs.matches(rule, 'test ing.f'));
      assert.isTrue(rs.matches(rule, 'test ing.F'));
    }
    test();
    rule.pattern = 'F';
    test();
  });

  it("matches() EXT_EQ doesn't match files with no extension", async function() {
    let rule: Rule = {
      type: 'EXT_EQ',
      pattern: 'f',
    };
    function test() {
      assert.isFalse(rs.matches(rule, 'f'));
      assert.isFalse(rs.matches(rule, 'F'));
      // we don't consider dotfiles to have file extensions
      assert.isFalse(rs.matches(rule, '.f'));
      assert.isFalse(rs.matches(rule, '.F'));
    }
    test();
    rule.pattern = 'F';
    test();
  });

  it("matches() EXT_EQ works for files with multiple dots in their name", async function() {
    let rule: Rule = {
      type: 'EXT_EQ',
      pattern: 'f',
    };
    function test() {
      assert.isTrue(rs.matches(rule, 'testing.there.f'));
      assert.isTrue(rs.matches(rule, 'testing.there.F'));
      assert.isTrue(rs.matches(rule, '.testing.there.F'));
      assert.isTrue(rs.matches(rule, '.testing.there.f'));
      assert.isFalse(rs.matches(rule, '.testing.there.f.x'));
      assert.isFalse(rs.matches(rule, '.testing.there.f.xy'));
    }
    test();
    rule.pattern = 'F';
    test();
  });

  it("matches() EXT_EQ matches extensions with comma", async function() {
    let rule: Rule = {
      type: 'EXT_EQ',
      pattern: '   a, Bc ,dEf',
    };
    assert.isTrue(rs.matches(rule, 'there.a'));
    assert.isTrue(rs.matches(rule, 'testing.there.A'));
    assert.isTrue(rs.matches(rule, '.testing.there.A'));
    assert.isTrue(rs.matches(rule, 'there.bc'));
    assert.isTrue(rs.matches(rule, 'testing.there.bC'));
    assert.isTrue(rs.matches(rule, '.testing.there.BC'));
    assert.isTrue(rs.matches(rule, 'there.def'));
    assert.isTrue(rs.matches(rule, 'testing.there.dEf'));
    assert.isTrue(rs.matches(rule, '.testing.there.DEF'));
    assert.isFalse(rs.matches(rule, 'test.a,Bc,dEf'));
    assert.isFalse(rs.matches(rule, 'test.de'));
    assert.isFalse(rs.matches(rule, 'test.ef'));
    assert.isFalse(rs.matches(rule, 'test.b'));
    assert.isFalse(rs.matches(rule, 'test.c'));
  });

  it("matches() GLOB behaves same as name contains when no control chars are used", async function() {
    let rule: Rule = {
      type: 'GLOB',
      pattern: 'sup',
    };
    assert.isTrue(rs.matches(rule, 'heysup'));
    assert.isTrue(rs.matches(rule, 'heySup'));
    assert.isFalse(rs.matches(rule, 'up'));
    assert.isFalse(rs.matches(rule, ''));
  });

  it("matches() GLOB escapes regex control chars", async function() {
    let rule: Rule = {
      type: 'GLOB',
      pattern: '.',
    };
    assert.isTrue(rs.matches(rule, 'a.b'));
    assert.isFalse(rs.matches(rule, 'ab'));
  });

  it("matches() GLOB star", async function() {
    let rule: Rule = {
      type: 'GLOB',
      pattern: 'Hi*There',
    };
    assert.isTrue(rs.matches(rule, 'hithere'));
    assert.isTrue(rs.matches(rule, 'hitHEre'));
    assert.isTrue(rs.matches(rule, 'hi   tHEre'));
    assert.isTrue(rs.matches(rule, 'hi .x! tHEre'));
    assert.isTrue(rs.matches(rule, 'xhi .x! tHErex'));
    assert.isFalse(rs.matches(rule, 'ithere'));
    assert.isFalse(rs.matches(rule, 'h ithere'));
  });

  it("matches() GLOB question mark", async function() {
    let rule: Rule = {
      type: 'GLOB',
      pattern: 'Hi?There',
    };
    assert.isTrue(rs.matches(rule, 'hithere'));
    assert.isTrue(rs.matches(rule, 'hitHEre'));
    assert.isTrue(rs.matches(rule, 'hi tHEre'));
    assert.isTrue(rs.matches(rule, 'hixtHEre'));
    assert.isTrue(rs.matches(rule, 'xhi.tHErex'));
    assert.isFalse(rs.matches(rule, 'ithere'));
    assert.isFalse(rs.matches(rule, 'h ithere'));
  });

  it("matches() NAME_CONTAINS", async function() {
    let rule: Rule = {
      type: 'NAME_CONTAINS',
      pattern: 'AbC',
    };
    assert.isTrue(rs.matches(rule, 'abc'));
    assert.isTrue(rs.matches(rule, 'AbC'));
    assert.isTrue(rs.matches(rule, 'aBc '));
    assert.isTrue(rs.matches(rule, ' AbC '));
    assert.isTrue(rs.matches(rule, 'x abC .pdf'));
    assert.isTrue(rs.matches(rule, 'x Abc .pdfAbC'));
    assert.isFalse(rs.matches(rule, 'bc'));
    assert.isFalse(rs.matches(rule, 'a bc'));
  });
});
