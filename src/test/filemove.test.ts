import { datastore as ds, UserService, FileMove, FileMoveKey, FileMoveService as fms } from '../models';
import { assert } from 'chai';

describe("FileMove", function() {
  let ownerId: string;
  let nonNumericOwnerId: string;

  beforeEach(async function() {
    let user = UserService.makeNew();
    let [id] = await UserService.save([user]);
    if (! id) {
      throw new Error('Created new user but did not get back id');
    }
    ownerId = id;

    // Create another user with non-numeric ownerId
    nonNumericOwnerId = user.id = 'xxx:' + id;
    await UserService.save([user]);
  });

  function newFM(): FileMove {
    let ret = fms.makeNew(ownerId);
    ret.fromFile = "from";
    ret.toDir = "to";
    ret.resolvedName = "resolved to";
    ret.hasCollision = true;
    return ret;
  }

  it('validation: object with only required fields is valid', function() {
    let fm: FileMove = {
      fromFile: 'a',
      toDir: '',
      when: new Date(),
      hasCollision: true
    };
    let error = fms.validate([fm]);
    assert.notOk(error);
  });

  it('validation: object with null optional field is valid', function() {
    let fm: any = {
      fromFile: 'a',
      toDir: 'a',
      when: new Date(),
      hasCollision: true,
      resolvedName: null
    };
    let error = fms.validate([fm]);
    assert.notOk(error);
  });

  it('validation: object with all fields is valid', function() {
    let fm: FileMove = {
      fromFile: 'a',
      toDir: 'a',
      when: new Date(),
      hasCollision: true,
      resolvedName: 'res'
    };
    let error = fms.validate([fm]);
    assert.notOk(error);
  });

  it('validation: missing hasCollision', function() {
    let fm: FileMove = {
      fromFile: 'a',
      toDir: 'a',
      when: new Date(),
    };
    let error = fms.validate([fm]);
    assert.ok(error);
  });

  it('save(): missing toDir causes error', async function() {
    let fm = newFM();
    fm.toDir = undefined;
    let thrown = true;
    try {
      await fms.save([fm]);
      thrown = false;
    } catch (e) {}
    assert.ok(thrown);
  });

  it('save(): missing id throws error', async function() {
    let fm = newFM();
    fm.id = undefined;
    let thrown = true;
    try {
      await fms.save([fm]);
      thrown = false;
    } catch (e) {}
    assert.ok(thrown);
  });

  it('save(): missing ownerId throws error', async function() {
    let fm = newFM();
    assert.ok(fm.id);
    (fm.id as FileMoveKey).ownerId = undefined;
    let thrown = true;
    try {
      await fms.save([fm]);
      thrown = false;
    } catch (e) {}
    assert.ok(thrown);
  });

  it('save(): can save with missing fileMoveId', async function() {
    let fm = newFM();
    assert.notOk((fm.id as FileMoveKey).fileMoveId);
    let [id] = await fms.save([fm]);
    assert.ok(id);
    if (id) {
      assert.equal(id.ownerId, ownerId);
      assert.ok(id.fileMoveId);
    }
  });

  it('save(): can save with missing fileMoveId and get it back', async function() {
    let fm = newFM();
    assert.notOk((fm.id as FileMoveKey).fileMoveId);
    let id: FileMoveKey;
    [id] = await fms.save([fm]) as FileMoveKey[];
    assert.ok(id);
    assert.equal(id.ownerId, ownerId);
    assert.ok(id.fileMoveId);
    let [fromDS] = await fms.findByIds([id]);
    // fileMoveId is generated by datastore, let's add it to the fileMove that we
    // created
    fm.id = id;
    assert.deepEqual(fromDS, fm);
  });

  it('save(): modify fileMove with id save, then read it back', async function() {
    let fm = newFM();
    let id: FileMoveKey;
    [id] = await fms.save([fm]) as FileMoveKey[];
    assert.ok(id);
    assert.equal(id.ownerId, ownerId);
    assert.ok(id.fileMoveId);
    let [fromDS] = await fms.findByIds([id]);
    // ruleId is generated by datastore, let's add it to the rule that we
    // created
    fm.id = id;
    assert.deepEqual(fromDS, fm);

    // Modify
    fm.resolvedName = undefined;
    fm.hasCollision = false;
    await fms.save([fm]);
    [fromDS] = await fms.findByIds([id]);
    assert.deepEqual(fromDS, fm);
  });

  it('save(): modify fileMove with id save, then read it back, non-numeric id', async function() {
    let fm = newFM();
    (fm.id as FileMoveKey).ownerId = nonNumericOwnerId;
    let id: FileMoveKey;
    [id] = await fms.save([fm]) as FileMoveKey[];
    assert.ok(id);
    assert.equal(id.ownerId, nonNumericOwnerId);
    assert.ok(id.fileMoveId);
    let [fromDS] = await fms.findByIds([id]);
    // ruleId is generated by datastore, let's add it to the rule that we
    // created
    fm.id = id;
    assert.deepEqual(fromDS, fm);

    // Modify
    fm.resolvedName = undefined;
    fm.hasCollision = false;
    await fms.save([fm]);
    [fromDS] = await fms.findByIds([id]);
    assert.deepEqual(fromDS, fm);
  });


  it('toEntity(): cannot convert filemove with missing id', async function() {
    let fm = newFM();
    fm.id = undefined;
    let thrown = true;
    try {
      fms.toEntity(fm);
      thrown = false;
    } catch (e) { }
    assert.isTrue(thrown);
  });

  it('toEntity(): cannot convert filemove with missing ownerId', async function() {
    let fm = newFM();
    let rk = new FileMoveKey();
    rk.fileMoveId = '123';
    fm.id = rk;
    let thrown = true;
    try {
      fms.toEntity(fm);
      thrown = false;
    } catch (e) { }
    assert.isTrue(thrown);
  });

  it('toEntity(): can convert filemove with missing fileMoveId', async function() {
    let fm = newFM();
    let rk = new FileMoveKey();
    rk.ownerId = 'sup';
    rk.fileMoveId = undefined;
    fm.id = rk;
    fms.toEntity(fm);
  });

  it('keyFromId(): cannot convert missing id', async function() {
    let thrown = true;
    try {
      fms.keyFromId(undefined);
      thrown = false;
    } catch (e) { }
    assert.isTrue(thrown);
  });

  it('keyFromId(): cannot convert missing ownerId', async function() {
    let fmk = new FileMoveKey();
    fmk.ownerId = undefined;
    fmk.fileMoveId = '123';
    let thrown = true;
    try {
      fms.keyFromId(fmk);
      thrown = false;
    } catch (e) { }
    assert.isTrue(thrown);
  });

  it('keyFromId(): converts non-numeric ownerId to name', async function() {
    let fmk = new FileMoveKey();
    fmk.ownerId = 'xyz123';
    fmk.fileMoveId = undefined;
    let k = fms.keyFromId(fmk);
    assert.ok(k);
    // should be an incomplete key
    assert.equal(k.kind, fms.kind);
    assert.notOk(k.id);
    assert.ok(k.parent);

    // parent should be user
    assert.equal((k.parent as any).kind, UserService.kind);
    assert.equal((k.parent as any).name, fmk.ownerId);
  });

  it('keyFromId(): converts numeric ownerId to name', async function() {
    let fmk = new FileMoveKey();
    fmk.ownerId = '123';
    fmk.fileMoveId = undefined;
    let k = fms.keyFromId(fmk);
    assert.ok(k);
    // should be an incomplete key
    assert.equal(k.kind, fms.kind);
    assert.notOk(k.id);
    assert.ok(k.parent);

    // parent should be user
    assert.equal((k.parent as any).kind, UserService.kind);
    assert.equal((k.parent as any).id, fmk.ownerId);
  });

  it('keyFromId(): converts fileMoveId', async function() {
    let fmk = new FileMoveKey();
    fmk.ownerId = '123';
    fmk.fileMoveId = '555';
    let k = fms.keyFromId(fmk);
    assert.ok(k);

    // should be an incomplete key
    assert.equal(k.kind, fms.kind);
    assert.equal(k.id, fmk.fileMoveId);
    assert.ok(k.parent);

    // parent should be user
    assert.equal((k.parent as any).kind, UserService.kind);
    assert.equal((k.parent as any).id, fmk.ownerId);
  });


  it('idFromKey(): cannot handle empty key', function() {
    assert.throw(function() {
      fms.idFromKey(undefined as any);
    });
  });

  it('idFromKey(): numeric parent key', function() {
    let fmk = new FileMoveKey();
    fmk.ownerId = '123';
    fmk.fileMoveId = '555';
    let k = ds.key([UserService.kind, ds.int(fmk.ownerId), fms.kind, ds.int(fmk.fileMoveId)]);
    let actual = fms.idFromKey(k);
    assert.deepEqual(actual, fmk);
  });

  it('idFromKey(): non-numeric parent key', function() {
    let fmk = new FileMoveKey();
    fmk.ownerId = '123x';
    fmk.fileMoveId = '555';
    let k = ds.key([UserService.kind, fmk.ownerId, fms.kind, ds.int(fmk.fileMoveId)]);
    let actual = fms.idFromKey(k);
    assert.deepEqual(actual, fmk);
  });

  it('idFromKey() then keyFromId() returns the same as original input', function() {
    let fmk = new FileMoveKey();
    fmk.ownerId = '123';
    fmk.fileMoveId = '555';
    let k = fms.keyFromId(fmk);
    let actual = fms.idFromKey(k);
    assert.deepEqual(actual, fmk);
  });

  it('idFromKey() then keyFromId() returns the same as original input, non-numeric parent', function() {
    let fmk = new FileMoveKey();
    fmk.ownerId = 'x123';
    fmk.fileMoveId = '555';
    let k = fms.keyFromId(fmk);
    let actual = fms.idFromKey(k);
    assert.deepEqual(actual, fmk);
  });

  it("findByOwner()", async function() {
    let user = UserService.makeNew();
    [user.id] = await UserService.save([user]);
    let fileMoves: FileMove[] = [];
    let startDate = Date.now();
    for (let i = 0; i < 5; i++) {
      let fileMove = newFM();
      fileMove.when = new Date(startDate - i * 1e3);
      if (fileMove.id) {
        fileMove.id.ownerId = user.id;
      }
      fileMoves.push(fileMove);
    }
    let fileMoveIds = await fms.save(fileMoves);
    fileMoveIds.forEach((id, index) => {
      fileMoves[index].id = id;
    });

    let fromDS = await fms.findByOwner(user.id as string);
    assert.deepEqual(fromDS, fileMoves);
  });
});
